""" P.226 효율적인 화폐 구성 정답 """

# i는 금액, k는 화폐의 단위
# 점화식 : d[i] = min(d[i], d[i-k]+1)
# 만약 6원을 만들기 위해 2원 화폐를 사용하는 최소 화폐 개수 d[6]을 구하는 방식을 d[6-2] + 1
# 즉, d[6] = d[4] + 1로 나타내며, 여기서 +1이 2원 화폐를 "한 번" 사용한 것을 의미

# a(i-k)인 이유 : k는 지금 세고 있는 화페의 단위
# a(7-5) = a(2)가 존재하면(10001이 아니면) a(2)에 k(지금은 5)를 추가해서 2 + 5가 되기 때문에
# 그래서 a(2)인 a(i-k)에 +1을 해주면서 최소의 횟수를 추가해준다.

# 정수 N, M을 입력 받기
n, m = map(int, input().split())
# N개의 화폐 단위 정보를 입력 받기
array = []
for i in range(n):
    array.append(int(input()))

# DP 테이블 : 금액 i를 만들 수 있는 최소한의 화폐 개수
d = [10001] * (m + 1)  # 마지막에 d[m]을 출력할 것이고 인덱스 1부터 시작할 것이기 때문에 개수를 (m+1)로 한다

# 다이나믹 프로그래밍(Dynamic Programming) 진행(보텀업)
d[0] = 0
for i in range(n):
    # array[i]는 입력된 기준 화폐를 의미하는데 array[i]부터 시작하는 이유는
    # 점화식이 d[i] = min(d[i], d[i-k]+1) 인데 현재 기준 화폐의 크기(array[i])보다 작은 수부터 시작할 수 없기 때문이다
    for j in range(array[i], m + 1):
        # (i-k)원을 만드는 방법이 존재하는 경우 --> d[i-k] 값이 이전에 한 번이라도 조정이 되었다면(초기값이 아니라면)
        # 사실 이 부분은 없어도 되는 코드이다. 10001의 값을 가지더라도 min(d[j], d[j-array[i]] + 1)은 항상 d[j] 값을 반환하기 때문
        if d[j - array[i]] != 10001:
            # min 함수 안에 d[j]를 넣는 이유 : 이전에 반복문을 돌린 금액(array[i])의 조합이 더 작은 수 일수 있어서
            d[j] = min(d[j], d[j - array[i]] + 1)

# 계산된 결과 출력
if d[m] == 10001:  # 최종적으로 M원을 만드는 방법이 없을 경우
    print(-1)
else:
    print(d[m])
